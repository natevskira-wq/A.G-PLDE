<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PLDE - Procedural Language Drill Engine</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* BRUTALIST CSS - MOBILE OPTIMIZED */
        :root {
            --bg: #ffffff;
            --fg: #000000;
            --border: 3px solid #000000;
        }
        * { box-sizing: border-box; }
        
        body { 
            font-family: 'Courier New', monospace; 
            margin: 0; 
            padding: 0; 
            background: var(--bg); 
            color: var(--fg); 
            line-height: 1.4;
        }

        .app-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 200px; 
        }

        .view { display: none; }
        .active { display: block; }

        /* BREADCRUMBS */
        .breadcrumb-bar {
            font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 1px;
            border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-bottom: 15px;
            display: flex; justify-content: space-between;
        }

        /* LOGIN VIEW SPECIFIC */
        .centered-view {
            display: flex; flex-direction: column; justify-content: center;
            min-height: 80vh; text-align: center;
        }
        
        /* VECTOR CONTAINER */
        .vector-container {
            border: var(--border); padding: 30px 20px 20px 20px; margin: 30px 0; position: relative;
        }
        .vector-label {
            background: black; color: white; padding: 5px 10px; position: absolute;
            top: -15px; left: 15px; font-weight: bold; text-transform: uppercase;
            font-size: 14px; letter-spacing: 1px;
        }
        .language-pair { margin-bottom: 25px; }
        .language-label {
            display: block; margin-bottom: 8px; font-weight: bold; text-transform: uppercase;
            letter-spacing: 1px; font-size: 12px; color: #444;
        }
        
        select, input[type="text"] {
            width: 100%; padding: 15px; font-size: 18px; border: var(--border);
            font-family: monospace; background: white; -webkit-appearance: none;
            appearance: none; cursor: pointer; border-radius: 0; outline: none;
        }
        select:focus, input[type="text"]:focus { background: #f0f0f0; }
        
        /* CREDITS FOOTER */
        .credits-footer {
            margin-top: 60px; text-align: center; border-top: 2px solid #000;
            padding-top: 20px; color: #000;
        }
        .credits-name {
            font-weight: 900; color: #000; font-size: 22px;
            letter-spacing: 1px; margin-bottom: 8px;
        }
        .credits-phone {
            font-weight: bold; font-size: 18px; color: #000;
            margin-bottom: 8px; font-family: monospace;
        }
        .credits-title {
            font-size: 14px; font-weight: bold; letter-spacing: 2px; color: #000;
        }
        
        /* STICKY TIMER */
        #timer-sticky-wrapper {
            position: sticky; top: 0; background: var(--bg); z-index: 1000;
            border-bottom: var(--border); padding: 10px 20px; margin: 0 -20px 20px -20px; 
        }
        #timer-bar { height: 25px; background: #000000; width: 0%; transition: width 0.1s linear; }

        #phase-label {
            text-align: center; font-size: 14px; font-weight: bold; letter-spacing: 2px;
            color: #666; margin-bottom: 10px; text-transform: uppercase;
        }
        .cumulative-warning { color: red !important; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        #stage { 
            border: var(--border); padding: 30px 15px; margin: 20px 0; min-height: 200px; 
            text-align: center; font-size: 24px; display: flex; flex-direction: column;
            justify-content: center; align-items: center; word-wrap: break-word;
            overflow-wrap: break-word; max-width: 100%;
        }

        /* TEXT INTERACTION */
        .speakable { cursor: pointer; transition: color 0.2s; }
        .speakable:hover { color: #555; text-decoration: underline; }
        
        .translation-text {
            font-size: 0.9rem; color: #666; font-style: italic; margin-top: 10px; font-weight: normal;
        }
        
        .phonetic-text {
            font-family: 'Courier New', monospace;
            color: #800080; /* Purple */
            font-size: 0.9rem;
            margin-top: 5px;
            font-weight: bold;
        }

        /* STICKY ACTION FOOTER */
        #input-area { 
            text-align: center; position: fixed; bottom: 0; left: 0; width: 100%;
            background: white; border-top: 3px solid black; padding: 15px;
            z-index: 2000; box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
        }
        #user-input { margin-bottom: 10px; }

        button { 
            padding: 15px 25px; margin: 5px; font-size: 18px; border: var(--border); 
            background: white; color: black; font-family: monospace; font-weight: bold;
            cursor: pointer; text-transform: uppercase; min-height: 54px;
            touch-action: manipulation; border-radius: 0;
        }
        button:hover:not(:disabled) { background: black; color: white; }
        button:disabled { opacity: 0.3; cursor: not-allowed; border-color: #999; color: #999; }
        
        .lesson-btn { display: block; width: 100%; margin: 15px 0; text-align: left; position: relative; }
        .lesson-btn.locked { opacity: 0.5; cursor: not-allowed; background: #eee; }
        .lesson-btn.decayed {
            border-color: #FFD700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: borderPulse 2s infinite;
        }
        @keyframes borderPulse { 0% { border-color: #FFD700; } 50% { border-color: #FFA500; } 100% { border-color: #FFD700; } }

        .score-badge { float: right; font-size: 14px; background: black; color: white; padding: 2px 6px; }
        .badge-green { background: #00aa00 !important; }
        .badge-yellow { background: #bba500 !important; color: black !important; }
        .badge-red { background: #aa0000 !important; }
        
        .option-btn { display: block; width: 100%; margin: 15px 0; text-align: left; }
        .action-bar { display: flex; flex-direction: row; gap: 10px; justify-content: space-between; }
        .action-bar button { flex: 1; }
        
        /* AUDIO OPTION BUTTONS */
        .audio-options-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            margin-top: 20px;
        }
        .audio-option-btn {
            padding: 20px;
            text-align: left;
            font-size: 18px;
            background: #fff;
            color: #000;
            border: var(--border);
            width: 100%;
            transition: all 0.2s;
            cursor: pointer;
        }
        .audio-option-btn:hover {
            background: #f0f0f0;
        }
        .audio-option-btn.selected {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        .word-bank, .letter-bank { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin: 20px 0; }
        .word-btn, .letter-btn { 
            font-size: 20px; padding: 12px 18px; transition: all 0.2s ease;
            border: var(--border); background: white; color: black; cursor: pointer;
            font-family: monospace; text-transform: uppercase;
        }
        .letter-btn { font-size: 24px; padding: 15px; min-width: 50px; }
        .word-btn:not(:disabled):hover, .letter-btn:not(:disabled):hover {
            transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); background: black; color: white;
        }
        .letter-btn:disabled, .word-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        #selected-words-area {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
            margin: 20px 0; min-height: 60px; padding: 15px;
            border: 2px dashed #999; background: #f8f8f8; border-radius: 0; align-items: center;
        }
        .word-pill, .letter-pill {
            font-size: 20px; padding: 12px 18px; border: var(--border);
            background: white; color: black; cursor: pointer; font-family: monospace; font-weight: bold; position: relative;
        }
        .letter-pill { font-size: 24px; padding: 15px; min-width: 50px; }
        .word-pill:hover, .letter-pill:hover { background: black; color: white; }
        .word-pill::after, .letter-pill::after {
            content: "‚úï"; position: absolute; top: -8px; right: -8px;
            background: red; color: white; width: 20px; height: 20px;
            border-radius: 50%; font-size: 12px; display: flex;
            align-items: center; justify-content: center; opacity: 0;
            transform: scale(0.8); transition: all 0.2s ease;
        }
        .word-pill:hover::after, .letter-pill:hover::after { opacity: 1; transform: scale(1); }
        
        .sentence-instructions { font-size: 14px; color: #666; text-align: center; margin-bottom: 10px; font-style: italic; }

        #feedback { height: 40px; margin: 20px 0; font-size: 20px; font-weight: bold; text-align: center; text-transform: uppercase; }
        .fail-flash { animation: flashRed 0.5s; }
        @keyframes flashRed { 0%, 100% { background-color: white; } 50% { background-color: #ff0000; } }
        
        .correct-answer-display { font-size: 42px; font-weight: bold; color: #000; margin: 20px 0; text-align: center; line-height: 1.3; }
        .report-card { border: 4px solid black; padding: 20px; text-align: center; }
        .report-grade { font-size: 60px; font-weight: bold; margin: 20px 0; }
        .placeholder-box { border: 2px dashed #999; padding: 20px; background: #eee; margin: 10px 0; font-size: 14px; color: #555; }
        
        .header-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .settings-btn { padding: 8px 12px; font-size: 14px; min-height: auto; }
        
        .voice-feedback { font-size: 12px; color: #666; margin-top: 5px; text-transform: none; letter-spacing: 0; }
        .single-word-display { font-size: 32px; font-weight: bold; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 2px; }
        .voice-listening { background: red !important; color: white !important; }
        
        /* AUDIO PLAYING INDICATOR */
        .audio-playing-indicator {
            color: #0000FF;
            font-weight: bold;
            font-size: 14px;
            animation: pulse 1.5s infinite;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
<div class="app-container">

    <!-- LOGIN -->
    <div id="login-view" class="view">
        <div class="centered-view">
            <h1 style="text-transform: uppercase; border-bottom: 3px solid black; padding-bottom: 10px; margin-bottom: 40px;">PLDE // GATEWAY</h1>
            <div style="font-size: 60px; margin-bottom: 20px;">üîí</div>
            <div style="margin-bottom: 20px;">
                <input type="text" id="access-code" placeholder="ENTER CODE" style="text-align: center; font-size: 28px; letter-spacing: 2px;">
            </div>
            <button id="login-btn" style="width: 100%; font-size: 24px;">LOGIN</button>
            <div id="login-status" style="margin-top: 20px; color: red; font-weight: bold;"></div>
            <div style="display:none;">ACCESS LIMITED TO 2 DEVICES PER CODE</div>
            <div class="credits-footer">
                <div class="credits-name">CONCEPT & CODE BY ABD-ALRAHMAN GAMAL</div>
                <div class="credits-phone">01001395058</div>
                <div class="credits-title">LANGUAGE ENGINEER & EDUCATOR</div>
            </div>
        </div>
    </div>

    <!-- CONFIG -->
    <div id="language-selector-view" class="view">
        <h1 style="text-transform: uppercase; border-bottom: 3px solid black; padding-bottom: 10px;">PLDE // LANGUAGE SELECTOR</h1>
        <div class="vector-container">
            <div class="vector-label">DEFINE VECTOR</div>
            <div class="language-pair">
                <label class="language-label">I SPEAK (NATIVE)</label>
                <select id="native-select"><option value="">-- SELECT --</option></select>
            </div>
            <div class="language-pair">
                <label class="language-label">I LEARN (TARGET)</label>
                <select id="target-select"><option value="">-- SELECT --</option></select>
            </div>
            <div class="language-pair">
                <label class="language-label">DIFFICULTY</label>
                <select id="level-select">
                    <option value="ALL">ALL LEVELS</option>
                    <option value="A1">A1 (BEGINNER)</option>
                    <option value="A1.1">A1.1</option>
                    <option value="A1.2">A1.2</option>
                    <option value="A2">A2 (ELEMENTARY)</option>
                    <option value="A2.1">A2.1</option>
                    <option value="A2.2">A2.2</option>
                    <option value="B1">B1 (INTERMEDIATE)</option>
                    <option value="B1.1">B1.1</option>
                    <option value="B1.2">B1.2</option>
                    <option value="B2">B2 (UPPER INT)</option>
                    <option value="B2.1">B2.1</option>
                    <option value="B2.2">B2.2</option>
                    <option value="C1">C1 (ADVANCED)</option>
                    <option value="C2">C2 (PROFICIENCY)</option>
                </select>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 30px; font-size: 14px;">
            <div style="font-weight: bold;">AVAILABLE CONTENT STATUS:</div>
            <div id="available-pairs" style="color: #666; margin-top: 5px;">Scanning database...</div>
        </div>
        <div style="margin-top: 20px;">
            <button id="start-learning-btn" disabled style="width: 100%;">START LEARNING</button>
        </div>
    </div>

    <!-- DASHBOARD -->
    <div id="dashboard-view" class="view">
        <div class="header-bar">
            <h1 style="text-transform: uppercase; border-bottom: 3px solid black; padding-bottom: 10px; margin: 0; flex: 1;">DASHBOARD</h1>
            <button id="change-languages-btn" class="settings-btn" style="width:auto; height:auto;">‚Üê CHANGE LANGUAGE/LEVEL</button>
        </div>
        <div class="breadcrumb-bar" id="dashboard-breadcrumb"><span>LOADING...</span></div>
        <div id="dashboard-status" style="margin-bottom: 20px; font-weight: bold;">Initializing...</div>
        <div id="lessons-container"></div>
        <div style="margin-top: 50px; text-align: center; font-size: 10px; color: #999; border-top: 1px dashed #ccc; padding-top: 10px;">
            Engineered by Abd-Alrahman.Gamal - 01001395058
        </div>
    </div>

    <!-- DRILL -->
    <div id="drill-view" class="view">
        <div class="breadcrumb-bar" id="drill-breadcrumb">
            <span>DRILL</span><span id="drill-level-indicator">A1</span>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <button id="back-btn" style="padding: 10px; font-size: 14px; min-height: 40px; background: #000; color: #fff;">‚úï QUIT DRILL</button>
            <div id="lesson-title" style="font-weight: bold; font-size: 14px;"></div>
        </div>
        <div id="timer-sticky-wrapper"><div id="timer-bar"></div></div>
        <div id="phase-label">PHASE: INITIALIZING</div>
        <div id="step-info" style="text-align: right; font-size: 12px; margin-bottom: 5px;"></div>
        
        <!-- AUTO-PLAY INDICATOR -->
        <div id="autoplay-status" class="audio-playing-indicator" style="text-align: center; display: none;">üîä PLAYING...</div>

        <div id="stage"></div>
        <div id="feedback"></div>
        <div id="input-area">
            <input type="text" id="user-input" placeholder="TYPE HERE..." autocomplete="off" style="display: none;">
            <div class="action-bar">
                <button id="voice-btn">üé§ VOICE</button>
                <button id="submit-btn" disabled>SUBMIT</button>
            </div>
        </div>
    </div>
</div>

<script>
    // --- UNIVERSAL KOREAN MATCHER (V3) ---
    class UniversalKoreanMatcher {
      constructor(options = {}) {
        this.threshold = options.threshold || 0.7;
        this.useMultipleAlternatives = options.useMultipleAlternatives !== false;
        this.particles = [
          'ÏùÄ', 'Îäî', 'Ïù¥', 'Í∞Ä', 'ÏùÑ', 'Î•º', 'Ïùò', 'Ïóê', 'ÏóêÏÑú', 'Î°ú', 'ÏúºÎ°ú',
          'Í≥º', 'ÏôÄ', 'ÎèÑ', 'Îßå', 'ÍπåÏßÄ', 'Î∂ÄÌÑ∞', 'ÌïúÌÖå', 'Íªò', 'Ïù¥ÏóêÏöî', 'ÏòàÏöî',
          'ÏûÖÎãàÎã§', 'Ïù¥Ïïº', 'Ïïº', 'Ïù¥Îã§', 'ÎùºÍ≥†', 'Í≥†', 'Ïöî', 'ÏäµÎãàÎã§', 'Ìï©ÎãàÎã§',
          'Ï£†', 'ÎÇò', 'Îãà', 'Ïãú', 'ÏÑ∏Ïöî' 
        ];
        this.phoneticMap = {
          '„Ñ≤': '„Ñ±', '„Öã': '„Ñ±', '„Ñ∏': '„Ñ∑', '„Öå': '„Ñ∑', '„ÖÉ': '„ÖÇ', '„Öç': '„ÖÇ',
          '„ÖÜ': '„ÖÖ', '„Öâ': '„Öà', '„Öä': '„Öà', 'ÎÖú': 'ÎÑ§'
        };
      }

      match(spoken, correct, options = {}) {
        if (!spoken || !correct) return this.createResult(false, 0);
        
        const spokenVariants = this.generateVariants(spoken);
        const correctVariants = this.generateVariants(correct);
        let bestMatch = { similarity: 0, method: 'none', variant: null };

        // 0. SINGLE SYLLABLE MERCY
        if (correct.length === 1 && spoken.length > 0) {
            const targetJamo = this.decomposeToJamo(correct);
            const spokenJamo = this.decomposeToJamo(spoken.charAt(0)); 
            if (targetJamo.length >= 2 && spokenJamo.length >= 2) {
                if (targetJamo[1] === spokenJamo[1]) {
                    return this.createResult(true, 1.0, 'single-syllable-vowel-match');
                }
            }
        }

        for (const sv of spokenVariants) {
          for (const cv of correctVariants) {
            if (sv === cv) return this.createResult(true, 1.0, 'exact', sv, cv);
            if (sv.includes(cv) || cv.includes(sv)) {
                const lenRatio = Math.min(sv.length, cv.length) / Math.max(sv.length, cv.length);
                if (lenRatio > 0.4 || (cv.length <= 2 && sv.includes(cv))) {
                    const score = 0.9;
                    if (score > bestMatch.similarity) {
                        bestMatch = { similarity: score, method: 'contains', spokenVariant: sv, correctVariant: cv };
                    }
                }
            }
            const dist = this.levenshteinDistance(sv, cv);
            if (cv.length <= 3 && dist <= 1) {
                 const score = 0.9;
                 if (score > bestMatch.similarity) {
                    bestMatch = { similarity: score, method: 'short-fuzzy', spokenVariant: sv, correctVariant: cv };
                 }
            }
            const maxLen = Math.max(sv.length, cv.length);
            const similarity = 1 - (dist / maxLen);
            if (similarity > bestMatch.similarity) {
              bestMatch = { similarity, method: 'fuzzy', spokenVariant: sv, correctVariant: cv };
            }
          }
        }

        const threshold = options.threshold || this.threshold;
        const isMatch = bestMatch.similarity >= threshold;
        return this.createResult(isMatch, bestMatch.similarity, bestMatch.method, bestMatch.spokenVariant, bestMatch.correctVariant);
      }

      generateVariants(text) {
        const variants = new Set();
        variants.add(text);
        const normalized = this.deepNormalize(text);
        variants.add(normalized);
        const withoutParticles = this.stripParticles(normalized);
        variants.add(withoutParticles);
        const phonetic = this.phoneticNormalize(normalized);
        variants.add(phonetic);
        const phoneticNoParticles = this.stripParticles(phonetic);
        variants.add(phoneticNoParticles);
        const noSpaces = normalized.replace(/\s+/g, '');
        variants.add(noSpaces);
        const jamo = this.decomposeToJamo(normalized);
        variants.add(jamo);
        return Array.from(variants).filter(v => v && v.length > 0);
      }

      deepNormalize(text) {
        return text.trim().toLowerCase().replace(/\s+/g, ' ').replace(/[.,!?~¬∑]/g, '').normalize('NFC');
      }

      stripParticles(text) {
        let result = text;
        const sorted = [...this.particles].sort((a, b) => b.length - a.length);
        for (const particle of sorted) {
          if (result.endsWith(particle)) result = result.slice(0, -particle.length);
          const words = result.split(' ');
          result = words.map(word => {
            if (word.endsWith(particle) && word.length > particle.length) return word.slice(0, -particle.length);
            return word;
          }).join(' ');
        }
        return result.trim();
      }

      phoneticNormalize(text) {
        let result = text;
        for (const [variant, base] of Object.entries(this.phoneticMap)) {
          result = result.replace(new RegExp(variant, 'g'), base);
        }
        return result;
      }

      decomposeToJamo(text) {
        const CHO = ['„Ñ±','„Ñ≤','„Ñ¥','„Ñ∑','„Ñ∏','„Ñπ','„ÖÅ','„ÖÇ','„ÖÉ','„Öá','„Öà','„Öâ','„Öä','„Öã','„Öå','„Öç','„Öé'];
        const JUNG = ['„Öè','„Öê','„Öë','„Öí','„Öì','„Öî','„Öï','„Öñ','„Öó','„Öò','„Öô','„Öö','„Öõ','„Öú','„Öù','„Öû','„Öü','„Ö†','„Ö°','„Ö¢','„Ö£'];
        const JONG = ['','„Ñ±','„Ñ≤','„Ñ≥','„Ñ¥','„Ñµ','„Ñ∂','„Ñ∑','„Ñπ','„Ñ∫','„Ñª','„Ñº','„ÑΩ','„Ñæ','„Ñø','„ÖÄ','„ÖÅ','„ÖÇ','„ÖÑ','„ÖÖ','„ÖÜ','„Öá','„Öà','„Öä','„Öã','„Öå','„Öç','„Öé'];
        let result = '';
        for (const char of text) {
          const code = char.charCodeAt(0);
          if (code >= 0xAC00 && code <= 0xD7A3) {
            const syllableIndex = code - 0xAC00;
            const choIndex = Math.floor(syllableIndex / 588);
            const jungIndex = Math.floor((syllableIndex % 588) / 28);
            const jongIndex = syllableIndex % 28;
            result += CHO[choIndex] + JUNG[jungIndex] + JONG[jongIndex];
          } else {
            result += char;
          }
        }
        return result;
      }

      calculateSimilarity(str1, str2) {
        if (str1 === str2) return 1.0;
        const longer = str1.length > str2.length ? str1 : str2;
        if (longer.length === 0) return 1.0;
        const distance = this.levenshteinDistance(str1, str2);
        return (longer.length - distance) / longer.length;
      }

      levenshteinDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
        for (let j = 1; j <= str2.length; j++) {
          for (let i = 1; i <= str1.length; i++) {
            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + indicator);
          }
        }
        return matrix[str2.length][str1.length];
      }

      createResult(match, confidence, method = 'none', spokenVariant = null, correctVariant = null) {
        return { match, confidence: Math.round(confidence * 100) / 100, method, debug: { spokenVariant, correctVariant } };
      }

      matchWithAlternatives(alternatives, correct, options = {}) {
        let bestResult = this.createResult(false, 0);
        for (const alt of alternatives) {
          const result = this.match(alt.transcript, correct, options);
          const weightedConfidence = result.confidence * (alt.confidence || 1.0);
          if (weightedConfidence > bestResult.confidence) {
            bestResult = { ...result, confidence: weightedConfidence, originalTranscript: alt.transcript, sttConfidence: alt.confidence };
          }
        }
        return bestResult;
      }
    }

    const koreanMatcher = new UniversalKoreanMatcher();

    // --- CONSTANTS ---
    const DECAY_MS = 3 * 24 * 60 * 60 * 1000;
    const LANGUAGES = [
        { code: "ar", name: "ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabic)" },
        { code: "de", name: "Deutsch (German)" },
        { code: "en", name: "English" },
        { code: "es", name: "Espa√±ol (Spanish)" },
        { code: "fr", name: "Fran√ßais (French)" },
        { code: "ko", name: "ÌïúÍµ≠Ïñ¥ (Korean)" },
        { code: "ru", name: "–†—É—Å—Å–∫–∏–π (Russian)" }
    ];
    
    const FILLER_WORDS = ['the', 'a', 'an', 'and', 'or', 'to', 'is', 'are'];
    const LANGUAGE_STORAGE_KEY = 'PLDE_LANGUAGE_PAIR'; 
    const SUPABASE_URL = 'https://syrhuxxryctrzjdzexnx.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN5cmh1eHhyeWN0cnpqZHpleG54Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxMjYzMjUsImV4cCI6MjA4MDcwMjMyNX0.DP4O-USLYPbjGoTwM2fSc8juzLsABrDbGpQ-7CxSAXQ';

    // --- STATE ---
    const appState = {
        accessCode: '', deviceFingerprint: '', dbProgress: {},
        userLanguagePair: { native: null, target: null },
        selectedLevel: 'ALL', lessons: [], currentLesson: null, currentLessonData: null,
        currentLinkIndex: 0, currentStepKey: '1_model', userInput: '', isAnswered: false,
        timerInterval: null, speechRecognition: null, isListening: false,
        isShowingCorrectAnswer: false, currentInputSource: 'keyboard',
        reorderState: { mode: null, originalTarget: '', shuffledItems: [], selectedItems: [], availableItems: new Map() },
        passedLinks: [], mistakeCount: 0, linksPassed: 0,
        inCumulativeMode: false, inFinalBossMode: false,
        cumulativeQueue: [], finalBossQueue: [], cumulativeIndex: 0,
        voiceCandidates: [],
        selectedAudioOption: null 
    };

    // --- INVISIBLE TTS ---
    let ttsState = { text: '', speed: 1.0 };

    function speak(text, lang, onEndCallback) {
        if (!text || !window.speechSynthesis) {
            if(onEndCallback) onEndCallback();
            return;
        }
        window.speechSynthesis.cancel();

        if (ttsState.text === text) {
            ttsState.speed = (ttsState.speed === 1.0) ? 0.5 : 1.0;
        } else {
            ttsState.text = text;
            ttsState.speed = 1.0;
        }

        const u = new SpeechSynthesisUtterance(text);
        u.rate = ttsState.speed;
        
        const voices = window.speechSynthesis.getVoices();
        const candidates = voices.filter(v => v.lang === lang || v.lang.startsWith(lang));
        let voice = candidates.find(v => v.name.includes("Google")) || candidates[0];
        
        if (voice) u.voice = voice;
        else u.lang = lang;

        if (onEndCallback) {
            u.onend = onEndCallback;
            u.onerror = onEndCallback; 
        }

        window.speechSynthesis.speak(u);
    }

    const elements = {};
    let supabaseClient = null;

    document.addEventListener('DOMContentLoaded', async () => {
        cacheElements();
        initSupabase();
        initSpeech();
        setupEvents();
        generateFingerprint();
        populateLanguageSelectors();
        
        history.replaceState({ view: 'login-view' }, "", "#login");
        document.getElementById('login-view').classList.add('active');

        const savedCode = localStorage.getItem('PLDE_CODE');
        if (savedCode) { elements.accessCodeInput.value = savedCode; handleLogin(); }
    });

    function cacheElements() {
        elements.loginView = document.getElementById('login-view');
        elements.loginBtn = document.getElementById('login-btn');
        elements.accessCodeInput = document.getElementById('access-code');
        elements.loginStatus = document.getElementById('login-status');
        
        elements.langView = document.getElementById('language-selector-view');
        elements.dashView = document.getElementById('dashboard-view');
        elements.drillView = document.getElementById('drill-view');
        
        elements.nativeSelect = document.getElementById('native-select');
        elements.targetSelect = document.getElementById('target-select');
        elements.levelSelect = document.getElementById('level-select');
        elements.startBtn = document.getElementById('start-learning-btn');
        elements.changeLangBtn = document.getElementById('change-languages-btn');
        elements.availablePairs = document.getElementById('available-pairs');
        
        elements.container = document.getElementById('lessons-container');
        elements.status = document.getElementById('dashboard-status');
        elements.dashBreadcrumb = document.getElementById('dashboard-breadcrumb');
        
        elements.stage = document.getElementById('stage');
        elements.phaseLabel = document.getElementById('phase-label');
        elements.input = document.getElementById('user-input');
        elements.submitBtn = document.getElementById('submit-btn');
        elements.voiceBtn = document.getElementById('voice-btn');
        elements.timerBar = document.getElementById('timer-bar');
        elements.feedback = document.getElementById('feedback');
        elements.title = document.getElementById('lesson-title');
        elements.stepInfo = document.getElementById('step-info');
        elements.inputArea = document.getElementById('input-area');
        elements.drillBreadcrumb = document.getElementById('drill-breadcrumb');
        elements.drillLevelInd = document.getElementById('drill-level-indicator');
        
        // Auto-play indicator
        elements.autoPlayStatus = document.getElementById('autoplay-status');
    }

    // --- NAVIGATION ---
    function navigateTo(viewId) {
        document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
        const target = document.getElementById(viewId);
        if(target) target.classList.add('active');
        if(viewId === 'dashboard-view') updateBreadcrumbs();
        if(viewId === 'drill-view') updateDrillHeader();
        history.pushState({ view: viewId }, "", "#" + viewId.replace('-view', ''));
        window.scrollTo(0,0);
    }

    window.onpopstate = (event) => {
        if (event.state && event.state.view) {
            const viewId = event.state.view;
            if (elements.drillView.classList.contains('active') && viewId !== 'drill-view') {
                stopTimer();
                if(appState.isListening && appState.speechRecognition) appState.speechRecognition.stop();
            }
            document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
        } else {
            document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
            elements.loginView.classList.add('active');
        }
    };

    function updateBreadcrumbs() {
        if(appState.userLanguagePair.native && appState.userLanguagePair.target) {
            const nat = appState.userLanguagePair.native.toUpperCase();
            const tar = appState.userLanguagePair.target.toUpperCase();
            const lvl = appState.selectedLevel;
            elements.dashBreadcrumb.innerHTML = `<span>${nat} > ${tar}</span><span>LEVEL: ${lvl}</span>`;
        }
    }

    function updateDrillHeader() {
        if(appState.currentLessonData) {
            elements.drillLevelInd.innerText = appState.currentLessonData.meta?.level || appState.selectedLevel;
        }
    }

    // --- AUTH ---
    function generateFingerprint() { appState.deviceFingerprint = navigator.userAgent + screen.width + screen.height; }
    function handleLogin() {
        const code = elements.accessCodeInput.value.trim().toUpperCase();
        if (!code) { elements.loginStatus.innerText = "PLEASE ENTER A CODE"; return; }
        elements.loginBtn.disabled = true; elements.loginStatus.innerText = "VERIFYING...";
        attemptLogin(code);
    }
    
    async function attemptLogin(code) {
        if (!supabaseClient) { elements.loginStatus.innerText = "DB ERROR"; return; }
        try {
            const { data: row, error } = await supabaseClient.from('user_profiles').select('*').eq('access_code', code).single();
            if (error || !row) { elements.loginStatus.innerText = "INVALID CODE"; elements.loginBtn.disabled = false; return; }
            
            const fp = appState.deviceFingerprint;
            let granted = false, update = null;
            if (row.device_1 === fp || row.device_2 === fp) granted = true;
            else if (!row.device_1) { granted = true; update = { device_1: fp }; }
            else if (!row.device_2) { granted = true; update = { device_2: fp }; }
            
            if (!granted) { elements.loginStatus.innerText = "DEVICE LIMIT (MAX 2)"; elements.loginBtn.disabled = false; return; }
            if (update) await supabaseClient.from('user_profiles').update(update).eq('access_code', code);
            
            appState.accessCode = code; appState.dbProgress = row.progress || {};
            localStorage.setItem('PLDE_CODE', code);
            navigateTo('language-selector-view');
            checkSavedLanguagePairDropdowns(); fetchAvailablePairs();
        } catch (e) { elements.loginStatus.innerText = "SYSTEM ERROR"; elements.loginBtn.disabled = false; }
    }

    // --- DATA & SYNC ---
    function getCurrentLevelKey() { return `${appState.userLanguagePair.native}_${appState.userLanguagePair.target}_${appState.selectedLevel}`; }
    async function saveProgress(lessonId, score) {
        const key = getCurrentLevelKey();
        if (!appState.dbProgress[key]) appState.dbProgress[key] = {};
        const currentEntry = appState.dbProgress[key][lessonId];
        const currentBest = currentEntry ? (currentEntry.score || 0) : 0;
        
        if (score >= currentBest) appState.dbProgress[key][lessonId] = { score: score, lastPlayed: Date.now() };
        else if (score >= 80 && currentEntry) currentEntry.lastPlayed = Date.now();

        try { await supabaseClient.from('user_profiles').update({ progress: appState.dbProgress }).eq('access_code', appState.accessCode); } 
        catch (e) { console.error("Sync Error", e); }
    }

    // --- SETUP ---
    function populateLanguageSelectors() {
        LANGUAGES.forEach(lang => {
            const o1 = document.createElement('option'); o1.value = lang.code; o1.textContent = lang.name;
            elements.nativeSelect.appendChild(o1);
            const o2 = document.createElement('option'); o2.value = lang.code; o2.textContent = lang.name;
            elements.targetSelect.appendChild(o2);
        });
        const updater = () => elements.startBtn.disabled = !(elements.nativeSelect.value && elements.targetSelect.value && elements.levelSelect.value);
        elements.nativeSelect.onchange = updater; elements.targetSelect.onchange = updater; elements.levelSelect.onchange = updater;
    }
    
    function checkSavedLanguagePairDropdowns() {
        const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                elements.nativeSelect.value = data.native; elements.targetSelect.value = data.target; elements.levelSelect.value = data.level;
                elements.startBtn.disabled = false;
            } catch (e) {}
        }
    }

    function initSupabase() { if (window.supabase) supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY); }

    async function fetchAvailablePairs() {
        if (!supabaseClient) return;
        try {
            const { data } = await supabaseClient.from('lessons').select('content');
            const pairs = new Set();
            data.forEach(l => {
                const c = (typeof l.content === 'string') ? JSON.parse(l.content) : l.content;
                if(c.meta) pairs.add(`${c.meta.native_language} ‚Üí ${c.meta.target_language} (${c.meta.level || '?'})`);
            });
            if (pairs.size > 0) elements.availablePairs.innerHTML = Array.from(pairs).sort().join('<br>');
        } catch (e) {}
    }

    async function fetchFilteredLessons() {
        if (!supabaseClient) return;
        elements.status.innerText = 'LOADING LESSONS...';
        try {
            const { data } = await supabaseClient.from('lessons').select('*').order('created_at', { ascending: true });
            appState.lessons = (data || []).filter(l => {
                try {
                    const c = (typeof l.content === 'string') ? JSON.parse(l.content) : l.content;
                    if (!c.meta) return false;
                    const dbNative = c.meta.native_language || '';
                    const dbTarget = c.meta.target_language || '';
                    const matchNative = dbNative.startsWith(appState.userLanguagePair.native);
                    const matchTarget = dbTarget.startsWith(appState.userLanguagePair.target);
                    const matchLevel = (appState.selectedLevel === 'ALL' || c.meta.level === appState.selectedLevel);
                    return matchNative && matchTarget && matchLevel;
                } catch { return false; }
            });
            
            // SORTING LOGIC
            const levelWeight = { "A1": 1, "A2": 2, "B1": 3, "B2": 4, "C1": 5, "C2": 6 };
            appState.lessons.sort((a, b) => {
                let cA = (typeof a.content === 'string') ? JSON.parse(a.content) : a.content;
                let cB = (typeof b.content === 'string') ? JSON.parse(b.content) : b.content;
                let levelA = (cA.meta?.level || '').toUpperCase();
                let levelB = (cB.meta?.level || '').toUpperCase();
                let wA = levelWeight[levelA] || 99;
                let wB = levelWeight[levelB] || 99;
                return wA - wB;
            });

            renderDashboard();
            if (appState.lessons.length === 0) elements.status.innerText = "";
            else elements.status.innerText = `FOUND ${appState.lessons.length} LESSONS`;
        } catch (e) { elements.status.innerText = 'DB ERROR'; }
    }

    // --- DASHBOARD RENDER ---
    function renderDashboard() {
        elements.container.innerHTML = '';
        const levelProgress = appState.dbProgress[getCurrentLevelKey()] || {};
        
        if (appState.lessons.length === 0) {
            elements.container.innerHTML = `
                <div style="padding:40px; text-align:center; border: 3px dashed #ccc;">
                    <div style="font-size:30px; margin-bottom:10px;">üì≠</div>
                    <strong>NO LESSONS FOUND</strong><br>
                    <div style="color:#666; margin-top:5px;">Try a different level or language pair.</div>
                    <button onclick="history.back()" style="margin-top:20px; width:100%; background:black; color:white;">‚Üê GO BACK </button>
                </div>`;
            return;
        }

        let hasDecayDebt = false;
        const now = Date.now();
        for (const lesson of appState.lessons) {
            const entry = levelProgress[lesson.id];
            if (entry && (entry.score || 0) > 0) {
                const lastPlayed = entry.lastPlayed || 0;
                if (lastPlayed > 0 && (now - lastPlayed) > DECAY_MS) { hasDecayDebt = true; break; }
            }
        }
        if (hasDecayDebt) elements.status.innerHTML = `<span style="color:red; font-weight:bold;">‚ö†Ô∏è DECAY DETECTED. REFRESH OLD LESSONS.</span>`;

        appState.lessons.forEach((lesson, index) => {
            const btn = document.createElement('button');
            btn.className = 'lesson-btn';
            const entry = levelProgress[lesson.id];
            const score = entry ? (entry.score || 0) : 0;
            const lastPlayed = entry ? (entry.lastPlayed || 0) : 0;
            const isDecayed = (score > 0) && (lastPlayed > 0 && (now - lastPlayed) > DECAY_MS);
            
            let isLocked = false, lockReason = "";
            if (index > 0) {
                const prevId = appState.lessons[index - 1].id;
                const prevScore = levelProgress[prevId] ? (levelProgress[prevId].score || 0) : 0;
                if (prevScore < 90) { isLocked = true; lockReason = "PREV < 90%"; }
            }
            if (hasDecayDebt && score === 0) { isLocked = true; lockReason = "FIX DECAY"; }

            const c = (typeof lesson.content === 'string') ? JSON.parse(lesson.content) : lesson.content;
            let badge = '';

            if (isLocked) {
                badge = `<span class="score-badge">üîí ${lockReason}</span>`;
                btn.classList.add('locked'); btn.disabled = true;
            } else if (isDecayed) {
                badge = `<span class="score-badge badge-yellow">‚ö†Ô∏è REFRESH (${score}%)</span>`;
                btn.classList.add('decayed'); btn.onclick = () => loadLesson(lesson);
            } else if (score >= 90) {
                badge = `<span class="score-badge badge-green">MASTERED (${score}%)</span>`;
                btn.onclick = () => loadLesson(lesson);
            } else if (score > 0) {
                badge = `<span class="score-badge">BEST: ${score}%</span>`;
                btn.onclick = () => loadLesson(lesson);
            } else {
                badge = `<span class="score-badge">NEW</span>`;
                btn.onclick = () => loadLesson(lesson);
            }
            
            btn.innerHTML = `<strong>${lesson.title}</strong>${badge}<br><span style="font-size:12px;color:#666">${c.meta?.level || ''}</span>`;
            elements.container.appendChild(btn);
        });
    }

    function loadLesson(lesson) {
        try {
            let c = (typeof lesson.content === 'string') ? JSON.parse(lesson.content) : lesson.content;
            if (!c.links) throw new Error('Bad Data');
            appState.currentLesson = lesson; appState.currentLessonData = c;
            
            if(c.meta?.randomize) {
                const arr = [...c.links];
                for(let i=arr.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
                appState.currentLessonData.links = arr;
            }

            appState.currentLinkIndex = 0; appState.currentStepKey = '1_model';
            appState.startTime = Date.now(); appState.mistakeCount = 0; appState.linksPassed = 0;
            appState.inCumulativeMode = false; appState.inFinalBossMode = false;
            appState.passedLinks = []; appState.finalBossQueue = [];
            
            navigateTo('drill-view'); startDrill();
        } catch(e) { alert(e.message); }
    }

    function startDrill() {
        elements.title.innerText = appState.currentLessonData.meta?.title || 'DRILL';
        renderStep();
    }

    function renderStep() {
        stopTimer(); resetInput(); appState.isShowingCorrectAnswer = false;
        elements.phaseLabel.classList.remove('cumulative-warning');
        elements.autoPlayStatus.style.display = 'none'; // Hide indicator by default
        
        const link = appState.currentLessonData.links[appState.currentLinkIndex];
        const step = link.steps[appState.currentStepKey];
        const meta = appState.currentLessonData.meta || {}; 
        
        elements.stepInfo.innerText = `${appState.currentLinkIndex + 1}/${appState.currentLessonData.links.length}`;
        elements.stage.innerHTML = '';
        updatePhaseLabel(step);
        
        const isInputStep = ['fill_gap','input_strict'].includes(step.type);
        if(!isInputStep) elements.input.style.display = 'none';
        else elements.input.style.display = 'block';
        
        // AUTO-PLAY LOGIC
        let shouldAutoPlay = (meta.audio_autoplay === true && step.type !== 'imprint');
        
        switch (step.type) {
            case 'imprint': renderImprint(link, step, meta); break;
            case 'multiple_choice': renderMultipleChoice(link, step); break;
            case 'audio_match': renderAudioMatch(link, step); break;
            case 'fill_gap': renderFillGap(link, step); break;
            case 'input_strict': renderInputStrict(link, step, meta); break;
            case 'sentence_reorder': renderSentenceReorder(link, step); break;
            default: elements.stage.innerHTML = `ERR: ${step.type}`;
        }
        
        if (step.time_limit) {
            if (shouldAutoPlay) {
                // Pause timer, play audio, then start timer
                elements.autoPlayStatus.style.display = 'block';
                // Find what to play (Trigger usually)
                const textToPlay = link.trigger.text;
                const langToPlay = meta.native_language; // Usually trigger is native
                
                speak(textToPlay, langToPlay, () => {
                    // On End
                    elements.autoPlayStatus.style.display = 'none';
                    startTimer(step.time_limit);
                });
            } else {
                startTimer(step.time_limit);
            }
        }
        else elements.timerBar.style.width = '0%';
    }

    function updatePhaseLabel(step) {
        let label = "DRILL";
        if(appState.inFinalBossMode) label = "FINAL BOSS";
        else if(appState.inCumulativeMode) { label = "CUMULATIVE REVIEW"; elements.phaseLabel.classList.add('cumulative-warning'); }
        else if(step.type === 'imprint') label = "PHASE 1: IMPRINT";
        else if(step.type === 'multiple_choice') label = "PHASE 2: RECOGNITION";
        else if(step.type === 'audio_match') label = "PHASE 2: LISTENING";
        else if(step.type === 'fill_gap') label = "PHASE 3: COMPLETION";
        else if(step.type === 'sentence_reorder') label = "PHASE 3: CONSTRUCTION";
        else if(step.type === 'input_strict') label = "PHASE 4: PRODUCTION";
        elements.phaseLabel.innerText = label;
    }

    // --- RENDER HELPERS ---
    function renderImprint(link, step, meta) {
        let html = '';
        const showText = meta.show_text !== false; 
        html += renderMedia(link.trigger, 'TRIGGER', meta.native_language, link.trigger.translation, null, true); 
        html += renderMedia(link.response, 'RESPONSE', meta.target_language, link.response.translation, link.response.phonetic, showText);
        
        elements.stage.innerHTML = html;
        elements.submitBtn.innerText = "READY";
        elements.submitBtn.disabled = false;
        elements.input.style.display = 'none';
        elements.voiceBtn.style.display = 'none';
    }

    function renderAudioMatch(link, step) {
        // Setup UI
        elements.input.style.display = 'none';
        elements.voiceBtn.style.display = 'none';
        elements.submitBtn.style.display = 'inline-block';
        elements.submitBtn.innerText = "CONFIRM";
        elements.submitBtn.disabled = true;

        appState.selectedAudioOption = null; // Reset selection

        // Render Trigger (Using renderMedia to respect image/text toggles)
        const meta = appState.currentLessonData.meta || {};
        let html = renderMedia(link.trigger, '', meta.native_language, null, null, true); 
        
        // Render Options Grid
        html += `<div class="audio-options-container">`;
        
        const lang = appState.currentLessonData.meta.target_language;
        const options = [...(step.options || [])];
        
        // Fisher-Yates shuffle
        for (let i = options.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [options[i], options[j]] = [options[j], options[i]];
        }

        options.forEach((opt, idx) => {
             const safeOpt = opt.replace(/'/g, "\\'");
             // Reusing handleAudioSelect logic
             html += `<button id="am-btn-${idx}" class="audio-option-btn" onclick="handleAudioSelect('${safeOpt}', 'am-btn-${idx}', '${lang}')">üîä LISTEN</button>`;
        });
        html += `</div>`;

        elements.stage.innerHTML = html;
    }

    function renderInputStrict(link, step, meta) {
        let html = `<div style="font-size:32px; font-weight:bold; margin-bottom:20px;">`;
        html += `<span class="speakable" onclick="speak('${link.trigger.text.replace(/'/g, "\\'")}', '${meta.native_language}')">${link.trigger.text}</span>`;
        if (link.trigger.translation) html += `<div class="translation-text">${link.trigger.translation}</div>`;
        if (link.trigger.phonetic) html += `<div class="phonetic-text">${link.trigger.phonetic}</div>`;
        html += `</div>`;
        
        // AUDIO MATCHER SAFETY MODE
        const isKorean = meta.target_language.startsWith('ko');
        const targetText = link.response.text;
        const isShort = (isKorean && targetText.length <= 2) || (!isKorean && targetText.length <= 3);

        if (isShort) {
            // HIDE INPUT & MIC
            elements.input.style.display = 'none';
            elements.voiceBtn.style.display = 'none';
            
            // GENERATE AUDIO OPTIONS
            renderAudioSelection(targetText, meta.target_language);
            
            // RENDER HEADER
            elements.stage.innerHTML = html + `<div id="audio-options-wrapper"></div>`;
            
            // Re-render buttons into wrapper
            setTimeout(() => {
                const wrapper = document.getElementById('audio-options-wrapper');
                if (wrapper && appState.audioOptionsHtml) {
                    wrapper.innerHTML = appState.audioOptionsHtml;
                }
            }, 0);
            
            // SETUP SUBMIT
            elements.submitBtn.innerText = "CONFIRM";
            elements.submitBtn.disabled = true; // Wait for selection
            elements.submitBtn.style.display = 'inline-block';
            
        } else {
            // STANDARD MODE
            elements.stage.innerHTML = html;
            elements.input.style.display = 'block';
            elements.submitBtn.style.display = 'inline-block';
            elements.submitBtn.disabled = true;
            elements.voiceBtn.style.display = 'inline-block';
            elements.submitBtn.innerText = "SUBMIT";
        }
    }
    
    // HELPERS FOR AUDIO MATCHER
    function getDistractors(correctText) {
        const links = appState.currentLessonData.links;
        const others = links.filter(l => l.response.text !== correctText);
        // Shuffle others
        for (let i = others.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [others[i], others[j]] = [others[j], others[i]];
        }
        // Return 2 text values
        return others.slice(0, 2).map(l => l.response.text);
    }

    function renderAudioSelection(correctText, lang) {
        appState.selectedAudioOption = null; // Reset
        
        const distractors = getDistractors(correctText);
        const options = [correctText, ...distractors];
        
        // Shuffle options
        for (let i = options.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [options[i], options[j]] = [options[j], options[i]];
        }
        
        let html = `<div class="audio-options-container">`;
        options.forEach((opt, idx) => {
             const safeOpt = opt.replace(/'/g, "\\'");
             html += `<button id="audio-btn-${idx}" class="audio-option-btn" onclick="handleAudioSelect('${safeOpt}', 'audio-btn-${idx}', '${lang}')">üîä LISTEN</button>`;
        });
        html += `</div>`;
        
        appState.audioOptionsHtml = html; // Store for injection
    }
    
    window.handleAudioSelect = (text, btnId, lang) => {
        // Play Audio
        speak(text, lang);
        
        // UI Update
        document.querySelectorAll('.audio-option-btn').forEach(b => b.classList.remove('selected'));
        document.getElementById(btnId).classList.add('selected');
        
        // Logic Update
        appState.selectedAudioOption = text;
        elements.submitBtn.disabled = false;
    };

    function renderMedia(obj, label, lang, translation, phonetic, showText = true) {
        if (!obj) return '';
        const meta = appState.currentLessonData.meta || {};
        // Override showText based on meta if not explicitly forced to false by caller
        const textVisible = showText && (meta.show_text !== false);
        const showTrans = meta.show_translation === true;
        const showPhone = meta.show_phonetic === true;
        const hasImage = obj.image_url && obj.image_url !== 'placeholder';

        let out = '<div style="margin: 15px 0;">';
        if (label) out += `<div style="font-size:12px; letter-spacing:2px; margin-bottom:5px;">${label}</div>`;

        // VISUAL TRIGGER MODE (Image Only)
        if (!textVisible && hasImage) {
             out += `<img src="${obj.image_url}" style="max-width:100%; max-height:300px; border: 2px solid #000; margin-bottom:10px;">`;
        }
        // STANDARD MODE (Text + Optional Image)
        else {
            if (textVisible && obj.text) {
                const safeText = obj.text.replace(/'/g, "\\'");
                out += `<div class="speakable" style="font-size:28px; font-weight:bold;" onclick="speak('${safeText}', '${lang}')">${obj.text}</div>`;
            }

            if (translation && showTrans) out += `<div class="translation-text">${translation}</div>`;
            if (phonetic && showPhone) out += `<div class="phonetic-text">${phonetic}</div>`;

            if (hasImage) {
                out += `<img src="${obj.image_url}" style="max-width:100%; max-height:200px; margin-top:10px;">`;
            }
        }

        if (obj.audio_url && obj.audio_url !== 'placeholder') {
            out += `<audio controls src="${obj.audio_url}" autoplay style="margin-top:10px; height:30px;"></audio>`;
        }
        out += '</div>';
        return out;
    }

    function renderMultipleChoice(link, step) {
        elements.input.style.display = 'none';
        elements.voiceBtn.style.display = 'none';
        elements.submitBtn.style.display = 'none'; 
        let html = `<div style="margin-bottom:30px; font-weight:bold; font-size:36px;">${link.trigger.text}</div>`;
        step.options.forEach(opt => {
            html += `<button class="option-btn" onclick="validate('${opt.replace(/'/g, "\\'")}', 'keyboard')">${opt}</button>`;
        });
        elements.stage.innerHTML = html;
    }

    function renderFillGap(link, step) {
        elements.stage.innerHTML = `<div style="font-size:20px; margin-bottom:20px;">${link.trigger.text}</div><div style="font-size:32px; font-weight:bold;">${step.sentence_structure}</div>`;
        elements.input.style.display = 'block';
        elements.submitBtn.style.display = 'inline-block';
        elements.submitBtn.disabled = true;
        elements.submitBtn.innerText = "SUBMIT";
    }

    function renderSentenceReorder(link, step) {
        elements.input.style.display = 'none'; 
        elements.voiceBtn.style.display = 'none';
        elements.submitBtn.style.display = 'inline-block';
        elements.submitBtn.innerText = "SUBMIT";
        
        const target = link.response.text;
        const words = target.split(' ').filter(w => w.length > 0);
        appState.reorderState.mode = (words.length === 1) ? 'letters' : 'words';
        appState.reorderState.originalTarget = target;
        
        const items = (appState.reorderState.mode === 'letters') ? target.split('') : words;
        const itemObjs = items.map((val, i) => ({ value: val, id: `item-${i}-${Date.now()}` }));
        
        appState.reorderState.shuffledItems = [...itemObjs];
        for (let i = appState.reorderState.shuffledItems.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [appState.reorderState.shuffledItems[i], appState.reorderState.shuffledItems[j]] = [appState.reorderState.shuffledItems[j], appState.reorderState.shuffledItems[i]];
        }
        
        appState.reorderState.selectedItems = [];
        appState.reorderState.availableItems.clear();
        itemObjs.forEach(i => appState.reorderState.availableItems.set(i.id, i));

        let html = `<div style="font-size:24px; font-weight:bold; margin-bottom:10px;">${link.trigger.text}</div>
                    <div id="selected-words-area"></div>
                    <div class="${appState.reorderState.mode === 'letters' ? 'letter-bank' : 'word-bank'}" id="bank-container"></div>`;
        
        elements.stage.innerHTML = html;
        updateReorderUI();
    }

    function updateReorderUI() {
        const bank = document.getElementById('bank-container');
        const area = document.getElementById('selected-words-area');
        if(!bank || !area) return;

        let bankHtml = '';
        appState.reorderState.shuffledItems.forEach(item => {
             const disabled = !appState.reorderState.availableItems.has(item.id);
             const cls = appState.reorderState.mode === 'letters' ? 'letter-btn' : 'word-btn';
             bankHtml += `<button class="${cls}" id="${item.id}" ${disabled?'disabled':''} onclick="handleReorderClick('${item.id}')">${item.value}</button>`;
        });
        bank.innerHTML = bankHtml;

        let areaHtml = '';
        if(appState.reorderState.selectedItems.length === 0) {
            areaHtml = '<div style="color:#999;">Tap items below...</div>';
        } else {
            appState.reorderState.selectedItems.forEach((item, idx) => {
                const cls = appState.reorderState.mode === 'letters' ? 'letter-pill' : 'word-pill';
                areaHtml += `<button class="${cls}" onclick="handleReorderRemove(${idx})">${item.value}</button>`;
            });
        }
        area.innerHTML = areaHtml;

        const joiner = appState.reorderState.mode === 'letters' ? '' : ' ';
        appState.userInput = appState.reorderState.selectedItems.map(i => i.value).join(joiner);
        elements.submitBtn.disabled = appState.reorderState.selectedItems.length !== appState.reorderState.shuffledItems.length;
    }

    window.handleReorderClick = (id) => {
        const item = appState.reorderState.availableItems.get(id);
        if(!item) return;
        appState.reorderState.selectedItems.push(item);
        appState.reorderState.availableItems.delete(id);
        updateReorderUI();
    };

    window.handleReorderRemove = (idx) => {
        const item = appState.reorderState.selectedItems[idx];
        appState.reorderState.selectedItems.splice(idx, 1);
        appState.reorderState.availableItems.set(item.id, item);
        updateReorderUI();
    };

    // --- VALIDATION ---
    function validate(val, source='keyboard') {
        if(appState.isShowingCorrectAnswer) return;
        
        // Handle "Audio Option" special case
        if (elements.submitBtn.innerText === "CONFIRM" && appState.selectedAudioOption) {
            val = appState.selectedAudioOption; // Use selected text instead of input
        }

        stopTimer();
        appState.currentInputSource = source;

        if(!appState.inCumulativeMode && !appState.inFinalBossMode) {
             const step = appState.currentLessonData.links[appState.currentLinkIndex].steps[appState.currentStepKey];
             if(step && step.type === 'imprint') { nextStep(); return; }
        }

        const targetLink = appState.inCumulativeMode ? appState.cumulativeQueue[appState.cumulativeIndex] : 
                           appState.inFinalBossMode ? appState.finalBossQueue[appState.cumulativeIndex] :
                           appState.currentLessonData.links[appState.currentLinkIndex];
        
        const target = targetLink.response.text;
        appState.userInput = val;
        const meta = appState.currentLessonData.meta || {};
        
        let passed = false;
        
        // Strict match for Audio Buttons (Exact text)
        if (elements.submitBtn.innerText === "CONFIRM") {
            passed = (val === target);
        }
        else if(source === 'voice') {
            if(meta && (meta.target_language.startsWith('ko'))) {
                const result = koreanMatcher.matchWithAlternatives(appState.voiceCandidates, target, {
                    threshold: meta.voice_threshold || 0.7 
                });
                passed = result.match;
            } else {
                const cleanUser = val.trim().toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                const cleanTarget = target.trim().toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
                const similarity = koreanMatcher.calculateSimilarity(cleanUser, cleanTarget);
                passed = similarity >= (meta.voice_threshold || 0.8);
            }
        } else {
            const cleanUser = val.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").replace(/\s+/g,' ').trim().toLowerCase();
            const cleanTarget = target.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").replace(/\s+/g,' ').trim().toLowerCase();
            passed = (cleanUser === cleanTarget);
        }

        if(passed) pass();
        else {
             if(appState.inCumulativeMode || appState.inFinalBossMode) failCumulative();
             else fail();
        }
    }

    function pass() {
        if (appState.isAnswered) return;
        appState.isAnswered = true;
        elements.feedback.style.color = 'green';
        elements.feedback.innerText = "CORRECT";
        
        if(!appState.inCumulativeMode && !appState.inFinalBossMode) {
            const l = appState.currentLessonData.links[appState.currentLinkIndex];
            if(!appState.passedLinks.some(pl=>pl.trigger.text===l.trigger.text)) appState.passedLinks.push(l);
        }

        setTimeout(() => {
            if(appState.inCumulativeMode) { appState.isAnswered=false; elements.feedback.innerText=""; nextCumulativeStep(); }
            else if(appState.inFinalBossMode) { appState.isAnswered=false; elements.feedback.innerText=""; nextFinalBossStep(); }
            else { appState.isAnswered=false; nextStep(); }
        }, 600);
    }

    function fail() {
        stopTimer();
        if(!appState.inCumulativeMode && !appState.inFinalBossMode) appState.mistakeCount++;
        document.body.classList.add('fail-flash');
        setTimeout(()=>document.body.classList.remove('fail-flash'),400);
        elements.feedback.style.color='red';
        elements.feedback.innerText="FAIL";
        
        setTimeout(()=>{ appState.currentStepKey='1_model'; renderStep(); }, 1000);
    }

    function failCumulative() {
        if(appState.isShowingCorrectAnswer) return;
        stopTimer();
        appState.isShowingCorrectAnswer = true;
        
        const link = appState.inCumulativeMode ? appState.cumulativeQueue[appState.cumulativeIndex] : appState.finalBossQueue[appState.cumulativeIndex];
        const meta = appState.currentLessonData.meta || {};

        elements.input.readOnly = true;
        elements.submitBtn.disabled = true;
        elements.voiceBtn.disabled = true;
        elements.feedback.style.color = 'red';
        elements.feedback.innerText = "WRONG";
        
        speak(link.response.text, meta.target_language);
        
        document.body.classList.add('fail-flash');
        setTimeout(()=>document.body.classList.remove('fail-flash'),400);

        elements.stage.innerHTML = `
            <div style="text-align:center;">
                <div style="color:#666;">YOU SAID: <span style="color:red;">${appState.userInput}</span></div>
                <div class="correct-answer-display">${link.response.text}</div>
                <div style="margin-top:20px;">RESTARTING CHAIN...</div>
            </div>`;
            
        setTimeout(() => {
            document.body.classList.remove('fail-flash');
            appState.cumulativeIndex = 0;
            appState.isShowingCorrectAnswer = false;
            
            // 1. DETERMINE WHICH QUEUE TO SHUFFLE
            let queueToShuffle = null;
            if (appState.inFinalBossMode) {
                queueToShuffle = appState.finalBossQueue;
            } else if (appState.inCumulativeMode) {
                queueToShuffle = appState.cumulativeQueue;
            }

            // 2. SHUFFLE IT (Fisher-Yates)
            if (queueToShuffle && queueToShuffle.length > 1) {
                for (let i = queueToShuffle.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [queueToShuffle[i], queueToShuffle[j]] = [queueToShuffle[j], queueToShuffle[i]];
                }
                console.log("Queue reshuffled on fail.");
            }
            
            // 3. RENDER
            if (appState.inFinalBossMode) {
                renderFinalBossStep();
            } else {
                renderCumulativeStep();
            }
        }, 2500);
    }

    // --- MODULAR LOOP & PHASES ---
    function nextStep() {
        const steps = Object.keys(appState.currentLessonData.links[appState.currentLinkIndex].steps).sort();
        const currIdx = steps.indexOf(appState.currentStepKey);
        
        // MODULAR PHASE LOGIC: Check meta.phases to see if we should skip
        let nextIdx = currIdx + 1;
        const phases = appState.currentLessonData.meta.phases || {};
        
        // Check if we can proceed to next steps
        while(nextIdx < steps.length) {
            const nextKey = steps[nextIdx];
            // Check flags
            if (nextKey === '2_recognition' && phases.recognition === false) { nextIdx++; continue; }
            if (nextKey === '3_reorder' && phases.reorder === false) { nextIdx++; continue; }
            if (nextKey === '4_production' && phases.production === false) { nextIdx++; continue; }
            if (nextKey === '5_timed_recall' && phases.recall === false) { nextIdx++; continue; }
            break; // Found a valid step
        }
        
        if(nextIdx < steps.length) {
            appState.currentStepKey = steps[nextIdx];
            renderStep();
        } else {
            appState.linksPassed++;
            const interval = appState.currentLessonData.meta.cumulative_interval || 3;
            
            // Cumulative Logic
            if(appState.linksPassed > 0 && appState.linksPassed % interval === 0 && appState.currentLinkIndex < appState.currentLessonData.links.length - 1) {
                if (appState.passedLinks.length > 0) {
                    appState.currentLinkIndex++;
                    startCumulativeDrill();
                    return;
                }
            }
            
            // Move to next link
            if(appState.currentLinkIndex < appState.currentLessonData.links.length - 1) {
                appState.currentLinkIndex++;
                appState.currentStepKey = Object.keys(appState.currentLessonData.links[appState.currentLinkIndex].steps).sort()[0];
                renderStep();
            } else {
                // End of Lesson
                checkForFinalBoss();
            }
        }
    }
    
    function checkForFinalBoss() {
        const phases = appState.currentLessonData.meta.phases || {};
        if (phases.final_boss === false) {
            showReportCard();
        } else {
            if(!appState.inFinalBossMode && !appState.inCumulativeMode) {
                startFinalBoss();
            } else {
                showReportCard();
            }
        }
    }

    // --- SUB-ROUTINES (CUMULATIVE & FINAL BOSS) ---
    function startCumulativeDrill() {
        if (!appState.passedLinks || appState.passedLinks.length === 0) { nextStep(); return; }
        appState.inCumulativeMode = true; appState.cumulativeIndex = 0;
        appState.cumulativeQueue = [...appState.passedLinks];
        renderCumulativeStep();
    }
    
    function renderCumulativeStep() {
        stopTimer(); resetInput(); appState.isShowingCorrectAnswer = false;
        const link = appState.cumulativeQueue[appState.cumulativeIndex];
        const meta = appState.currentLessonData.meta || {};
        elements.phaseLabel.innerText = "CUMULATIVE REVIEW";
        elements.phaseLabel.classList.add('cumulative-warning');
        
        renderInputStrict(link, null, meta);
        startTimer(7);
    }
    
    function nextCumulativeStep() {
        appState.cumulativeIndex++;
        if(appState.cumulativeIndex >= appState.cumulativeQueue.length) {
            appState.inCumulativeMode = false;
            // Return to normal flow logic (safety check)
            if(appState.currentLinkIndex < appState.currentLessonData.links.length) {
                const steps = Object.keys(appState.currentLessonData.links[appState.currentLinkIndex].steps).sort();
                appState.currentStepKey = steps[0];
                renderStep();
            } else startFinalBoss();
        } else renderCumulativeStep();
    }

    function startFinalBoss() {
        // Fix: Safety Check for empty links
        if (!appState.currentLessonData.links || appState.currentLessonData.links.length === 0) {
            showReportCard();
            return;
        }
        appState.inFinalBossMode = true;
        appState.finalBossQueue = [...appState.currentLessonData.links];
        appState.cumulativeIndex = 0;
        renderFinalBossStep();
    }
    
    function renderFinalBossStep() {
        stopTimer(); resetInput(); appState.isShowingCorrectAnswer = false;
        const link = appState.finalBossQueue[appState.cumulativeIndex];
        const meta = appState.currentLessonData.meta || {};
        elements.phaseLabel.innerText = "FINAL BOSS";
        
        renderInputStrict(link, null, meta);
        elements.input.placeholder = "One last time...";
        startTimer(7);
    }
    
    function nextFinalBossStep() {
        appState.cumulativeIndex++;
        if(appState.cumulativeIndex >= appState.finalBossQueue.length) {
            appState.inFinalBossMode = false;
            showReportCard();
        } else renderFinalBossStep();
    }

    function showReportCard() {
        const totalSteps = appState.currentLessonData.links.length * 5; 
        const totalAttempts = totalSteps + appState.mistakeCount;
        const accuracy = Math.round((totalSteps / totalAttempts) * 100);
        
        let grade = 'F', color = 'red';
        if (accuracy >= 95) { grade = 'S'; color = 'green'; }
        else if (accuracy >= 90) { grade = 'A'; color = 'green'; }
        else if (accuracy >= 80) grade = 'B'; 
        else if (accuracy >= 70) grade = 'C';
        
        if (color === 'green') saveProgress(appState.currentLesson.id, accuracy);

        elements.stage.innerHTML = `
            <div class="report-card">
                <h1>COMPLETE</h1>
                <div class="report-grade" style="color: ${color}">${grade}</div>
                <div class="report-stat">ACCURACY: ${accuracy}%</div>
                <button onclick="exitDrill()" style="margin-top: 20px; width: 100%;">BACK TO DASHBOARD</button>
            </div>`;
            
        elements.phaseLabel.innerText = "REPORT CARD";
        
        // Fix: Hiding sticky footer entirely to avoid overlap
        elements.inputArea.style.display = 'none';
        
        elements.input.style.display = 'none';
        elements.voiceBtn.style.display = 'none';
        elements.submitBtn.style.display = 'none';
        elements.timerBar.style.width = '0%';
    }
    
    window.exitDrill = () => {
        fetchFilteredLessons(); 
        history.back(); 
    };

    // --- EVENTS ---
    function setupEvents() {
        elements.loginBtn.onclick = handleLogin;
        elements.accessCodeInput.onkeydown = (e) => { if(e.key==='Enter') handleLogin(); };
        
        elements.startBtn.onclick = () => {
            appState.userLanguagePair = { native: elements.nativeSelect.value, target: elements.targetSelect.value };
            appState.selectedLevel = elements.levelSelect.value;
            localStorage.setItem(LANGUAGE_STORAGE_KEY, JSON.stringify({...appState.userLanguagePair, level: appState.selectedLevel}));
            fetchFilteredLessons();
            navigateTo('dashboard-view');
        };
        
        elements.changeLangBtn.onclick = () => history.back();
        document.getElementById('back-btn').onclick = () => history.back();

        elements.input.oninput = (e) => { appState.userInput = e.target.value; elements.submitBtn.disabled = !e.target.value.trim(); };
        elements.input.onkeydown = (e) => { 
            if(e.key === 'Enter') {
                const step = appState.currentLessonData?.links[appState.currentLinkIndex].steps[appState.currentStepKey];
                // Imprint step?
                if(step && step.type === 'imprint') validate('', 'keyboard');
                else if(!elements.submitBtn.disabled) validate(appState.userInput, 'keyboard');
            }
        };
        elements.submitBtn.onclick = () => validate(appState.userInput, 'keyboard');
    }

    function initSpeech() {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            elements.voiceBtn.style.display = 'none'; return;
        }
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        const sr = new SR();
        sr.continuous = false; sr.interimResults = true;
        sr.maxAlternatives = 5; 
        
        sr.onresult = (e) => {
            const results = e.results[e.results.length-1];
            if(results.isFinal) {
                appState.voiceCandidates = Array.from(results).map(r => ({
                    transcript: r.transcript,
                    confidence: r.confidence
                }));
                
                const t = results[0].transcript;
                elements.input.value = t; appState.userInput = t;
                elements.submitBtn.disabled = false;
                validate(t, 'voice');
            } else {
                elements.input.value = results[0].transcript;
            }
        };
        sr.onend = () => { appState.isListening = false; elements.voiceBtn.classList.remove('voice-listening'); elements.voiceBtn.innerText="üé§ VOICE"; };
        
        elements.voiceBtn.onclick = () => {
            if(appState.isListening) sr.stop();
            else {
                sr.lang = appState.currentLessonData?.meta?.target_language || 'en-US';
                sr.start(); appState.isListening = true; elements.voiceBtn.classList.add('voice-listening'); elements.voiceBtn.innerText="üî¥ LISTENING";
            }
        };
        appState.speechRecognition = sr;
    }

    function startTimer(sec) {
        appState.timerValue = sec; appState.timerMax = sec;
        elements.timerBar.style.width = '100%';
        appState.timerInterval = setInterval(() => {
            appState.timerValue -= 0.1;
            elements.timerBar.style.width = (appState.timerValue/appState.timerMax*100)+'%';
            if(appState.timerValue<=0) {
                if(appState.inCumulativeMode || appState.inFinalBossMode) failCumulative(); else fail();
            }
        }, 100);
    }
    function stopTimer() { clearInterval(appState.timerInterval); }
    function resetInput() {
        appState.isAnswered = false; appState.userInput = ''; 
        elements.input.value = ''; elements.input.readOnly = false;
        elements.voiceBtn.disabled = false; elements.submitBtn.disabled = true;
        elements.feedback.innerText = '';
        
        // Reset Footer Display
        elements.inputArea.style.display = 'block'; // Ensure container is visible
        elements.submitBtn.style.display = 'inline-block';
        elements.voiceBtn.style.display = 'inline-block';
        elements.input.style.display = 'block';
    }
</script>
</body>
</html>
